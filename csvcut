#!/usr/bin/env python

"""
csvcut is originally the work of eminent hackers Joe Germuska and Aaron Bycoffe.

This code is forked from:
https://gist.github.com/561347/9846ebf8d0a69b06681da9255ffe3d3f59ec2c97

Used and modified with permission.
"""

import csv 
import sys

import argparse

class ColumnIdentifierError(Exception):
    """
    Exception raised when the user supplies an invalid column identifier.
    """
    def __init__(self, msg):
        self.msg = msg

def parse_column_identifiers(ids, column_names):
    """
    Parse a comma-separated list of column indicies and names into a list of integer indices.
    """
    # If not specified, return all columns 
    if not ids:
        return range(len(column_names))

    columns = []

    for c in ids.split(','):
        if c in column_names:
            columns.append(column_names.index(c))
        else:
            try:
                c = int(c) - 1
            # Fail out if neither a column name nor an integer
            except:
                raise ColumnIdentifierError('Column identifier "%s" is neither a index, nor a existing column\'s name.' % c)

            # Fail out if index is 0-based
            if c < 0:
                raise ColumnIdentifierError('Columns 0 is not valid; columns are 1-based.')

            # Fail out if index is out of range
            if c >= len(column_names):
                raise ColumnIdentifierError('Index %i is beyond the last named column, "%s" at index %i.' % (c, column_names[-1], len(column_names) - 1))

            columns.append(c)

    return columns

def parse_row_identifiers(ids):
    if not ids:
        return None
    else:
        return [int(i) - 1 for i in ids.split(',')]

def main():
    """
    Command line-utility that filters and truncates CSV files. Like unix "cut" command, but for tabular data.

    Note: columns without a header are ignored (non-rectangular data).
    """
    parser = argparse.ArgumentParser(description='Filter and trucate CSV files. Like unix "cut" command, but for tabular data.')
    parser.add_argument('file', metavar="FILE", nargs='?', type=argparse.FileType('r'), default=sys.stdin,
                        help='The CSV file to operate on. If omitted, will accept input on STDIN.')
    parser.add_argument('-n', '--names', dest='show_headers', action='store_true',
                        help='Display column names and indices from the input CSV and exit.')
    parser.add_argument('-c', '--columns', dest='columns',
                        help='A comma separated list of column indices or names to be extracted. Defaults to all columns.')
    parser.add_argument('-r', '--rows', dest='rows',
                        help='A comma separated list of row indices to be extracted. Defaults to all rows.')
    parser.add_argument('-d', '--delimiter', dest='delimiter', default=',',
                        help='Delimiting character of the input CSV file. Defaults to comma.')
    parser.add_argument('-t', '--tabs', dest='tabs', action='store_true',
                        help='Specifies that the input CSV file is delimited with tabs. Overrides "-d".')
    parser.add_argument('-q', '--quotechar', dest='quotechar', default='"',
                        help='Character used to quote strings in the input CSV file. Defaults to double-quote.')

    args = parser.parse_args()

    # Determine rows to display
    rows = parse_row_identifiers(args.rows)

    # Create an output csv writer in advance, in order to save overhead
    writer = csv.writer(sys.stdout)

    i = 0

    for row in csv.reader(args.file, delimiter=args.delimiter, quotechar=args.quotechar):
        if i == 0:
            # Show headers and exit
            if args.show_headers:
                for i, c in enumerate(row):
                    print "%3i: %s" % (i, c)

                sys.exit()
            # Fetch column names for by-name indexing 
            else:
                column_names = row

                try:
                    columns = parse_column_identifiers(args.columns, column_names)
                except ColumnIdentifierError, e:
                    sys.exit(e.msg)

        if rows and i in rows: 
            writer.writerow([row[c] for c in columns])

        i+= 1

if __name__ == "__main__":
    main()
