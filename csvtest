#!/usr/bin/env python

from os.path import splitext

from csvkit import init_common_parser, extract_csv_reader_kwargs
from csvkit.unicode import UnicodeCSVReader, UnicodeCSVWriter

class CSVTestException(Exception):
    """
    Superclass for all row-test-failed exceptions. 
    All must have a line number, the problematic row, and a text explanation.
    """
    def __init__(self, line_number, row, msg):
        super(CSVTestException, self).__init__()
        self.msg = msg
        self.line_number = line_number
        self.row = row
        
class LengthMismatch(CSVTestException):
    """
    Encapsulate information about a row which as the wrong length.
    """
    def __init__(self, line_number, row, expected_length):
        msg = 'Expected length [%i], got length [%i]' % (expected_length, len(row))
        super(LengthMismatch, self).__init__(line_number, row, msg)
        
def main(args):
    """
    Test a CSV file for common errors.
    """
    reader = UnicodeCSVReader(args.file, **extract_csv_reader_kwargs(args))

    if args.clean:
        base, ext = splitext(args.file.name)
        cleaned = UnicodeCSVWriter(open('%s_out.csv' % base, 'w'))
        err = UnicodeCSVWriter(open('%s_err.csv' % base, 'w'))

    column_names = reader.next()

    if args.clean:
        cleaned.writerow(column_names)
        err_header = ['line_number','error']
        err_header.extend(column_names)
        err.writerow(err_header)
    
    for i,row in enumerate(reader):
        line_number = i + 2 # adjust for header row, plus add one for 1-based counting
        try:
            if len(row) != len(column_names):
                raise LengthMismatch(line_number,row,len(column_names))
            
            if args.clean:
                cleaned.writerow(row)
        except CSVTestException, e:
            if args.clean:
                err_row = [e.line_number, e.msg]
                err_row.extend(row)
                err.writerow(err_row)
            else:
                print "Line: %i: %s" % (e.line_number,e.msg)

if __name__ == '__main__':
    parser = init_common_parser(description='Perform a few basic sanity checks on a CSV file.')
    parser.add_argument('-c', '--clean', dest='clean', action='store_true',
                        help="""If this argument is present, two files will be created in the same
                                directory as the input file: [basename]_out.csv and [basename]_err.csv
                                The 'out' file will have only rows which pass all tests, and will have
                                the same structure as the input file. The 'err' file will have only rows
                                which fail tests, and will have two additional columns prepended to each row.
                                The first will have a line-number, and the second will have a textual explanation
                                of the error.""")

    main(parser.parse_args())
